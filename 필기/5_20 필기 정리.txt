05. 20. 필기

학습목표
1. 복습을 하면서 문자형 상수와 printf를 알아보자.
2. 논리연산자 NOT을 알아보자.
3. 형변환을 이해하자.
4. 우리가 많이 쓰는 문자열 타입을 이해해보자.
5. 블록스코프와 지역변수를 이해하자.
6. 제어문을 해보자.

********************************

printf()
출력 형식을 지정할 수 있는 메소드. 
System.out.printf("출력형식", 값, 값, 값 .. ); 의 형태.
Ex) 

형식지정자는 아래 오라클 문서 참조.
https://docs.oracle.com/javase/tutorial/java/data/numberformat.html

문자형 상수: 문자열 중간에 특수문자가 필요할 때 사용. char 데이터타입 변수에 문자형 상수도 넣을 수 있음.

\n 개행문자. 행갈이하는 역할을 함.
\t 수평탭
\b 백스페이스
\f 폼피드
등등

', ", \을 하나로 문자로서 쓸때는 앞에다 \을 써야 함.

***********************************

형변환
어떤 자료형의 값을 다른 자료형의 값으로 바꾸어 주는 연산.

자동적 형변환(프로모션): 자바 컴파일러가 필요한 경우 자동으로 이루어짐. 서로 다른 자료형의 연산에서 컴파일러가 자동적으로 큰 타입으로 변환하는 것 등. 또한 byte, short 타입은 명시적인 표현이 없는 이상 int로 인식하려고 함.

명시적 형변환(캐스팅): 변환되는 데이터 앞에 변환하고 싶은 자료형을 괄호 안에 넣기.
   ex)) double x = (double) 100;
   
확장 변환: 값보다 더 큰 크기의 변수로 값을 이동. 일반적으로 안전한 변환.
   
축소 변환: 더 작은 크기의 자료형에 값을 저장하는 형변환. 예로, 실수형 변수를 정수형 변수에 저장하는 것. 손실이 일어날 수 있음. 일례로, double 값을 int형 변수 안에 넣으면 소숫점 아래 부분이 날아감. 

형변환 연산자는 우선순위가 높고, 자동 형변환과 명시적인 형변환은 결과가 다를 수 있다.

********************************

String 타입은 참조형으로, 소문자로 시작했던 다른 데이터타입과 달리 대문자로 시작한다. 이는 클래스를 불러오는 것인 까닭이다. 
문자열 및 다른 데이터타입 간의 결합 연산이 가능하다. 이때 다른 데이터타입 값이 문자형으로 변환된다.
기본형과 같이 선언과 초기화를 동시에 할 수 있다.

  ex) String concat = str + 1 + "\n" + true + s2 + 3.0;
  

  String 클래스의 메소드:
  
- Index 관련
  Index: 문자열에서 인덱스(Index)란 해당 문자열에서 특정 문자의 위치를 가리킴.
  .chartAt(n); 문자열에서 인덱스값이 n인 문자를 char값으로 변환. n번째 문자를 셀 땐 1이 아니라 0부터 시작. 문자열 범위 밖이나 음수를 불러오려고 하면 에러가 남.
  .length(); 문자열의 길이를 알려줌.
  .indexOf("n" m); 문자열에서 문자 n의 인덱스를 정수 형태로 알려줌. 시작점을 m으로 지정. 해당 문자 n이 없으면 -1로 표시.
  .lastIndexOf("n"); 인덱스를 오른쪽에서부터 세어 찾음.

- 비교연산 
  String 타입은 관계연산자 "=="으로 값을 비교할 수 없음. "=="는 값을 비교하는 것이 아니라 참조대상(인스턴스)가 같은지 확인하는 로직으로 동작하기 때문.
  대신 메소드 a.equals(b); 로 a와 b의 값을 비교 가능.
  
- 기초형 타입 데이터를 String 타입으로 변환
  String.valueOf(a);
  
- String 타입의 입력
  .next(); 구분자가 spacebar
  .nextLine(); 구분자가 Line (한 줄을 통채로 읽음)
  
  문자열을 입력받을 때의 주의점: 문자열을 입력받기 이전에 정수같은 것을 입력하면 문제가 생김. 이것 때문에 제대로 동작하지 않을 경우 .nextLine();을 이용해 해결.
  
  

문자열과 인덱스와 메소드
Tstring, StringMethod 참조

문자열의 관계연산 equals

문자열 입력 InputrString
혹은 .next() 사용. next()는 스페이스를 구분자로 잡음.

********************************

public class BlockScope {
	public static void main(String[] args) {
	
	int a = 10;
	{{	
		System.out.println("가능?");
		System.out.println(a);
		int b = 101;
	}}	
	{ int b = 30;
	}
	
중괄호 짝만 맞으면 중괄호는 몇개든지 있어도 상관없음!
이 중괄호로 만드는 범위들을 "block scope"이라고 함.
큰 바깥범위에서 선언한 변수를 안에서 가져올 수 있다.	
작은 안범위에서 선언한 변수는 바깥으로 가져갈 수 없다.
  => 선언한 변수는 해당 블록스코프 안에서만 사용 가능.

이렇듯 범위가 정해져있는 변수를 '지역변수'라고 함.
한 블록스코프 안에서 하나의 변수에 이름은 하나만 와야 함.

지역변수의 반댓말은 '전역변수'로, 범위가 정해져있지 않아 프로그램 전체에서 쓸 수 있다.


*******************************
제어문: 순차진행에서 벗어나 프로그램을 원하는대로 짤 수 있게 해줌. 

If 문의 구조

if (조건식) {then절}
조건식의 연산결과는 boolean 타입.
안의 값이 참일 경우 if문의 중괄호 안 코드 실행.
중괄호 끝을 만난다면 다시 아래로 내려가 순차진행.
안의 값이 거짓일 경우 중괄호 안 코드를 실행하지 않는다. 건너뛰고 아래로 내려가 순차진행.

else {else절}: if문의 조건식 참이 아닐 때 실행

if절과 else절은 중첩, 연속적으로 사용할 수도 있다.

ex: (캡쳐2)(캡처3)


  
  조건문에 들어가는 "문장이 딱 하나일 때" 중괄호 생략 가능. 줄바꿈을 하지 않아도 됨. 다만 헷갈릴 경우가 많으니 붙여주는 것이 편함.
  
  ex) 		
  if(true) System.out.println("참"); else System.out.println("거짓");
    
  삼항연산자:
 boolean값 하나와 데이터 두개로 이루어진 연산. (데이터 값에 문자 넣을 수 없음!) 데이터 값 중 하나를 선택하는 것으로 간단한 if-else문과 같은 동작을 함.
  
  ex) 	boolean con=true;
		String result=(con)?"참":"거짓";
	    System.out.println(result);
  
  



************************
  <생각해보기>
  
  논리연산자 && || !
  
  형변환(Type conversion)(casting)
  자동적 형변환, 자료형의 확장
  명시적 형변환, 자료형의 축소, 자료 손실
  
  참조형 타입(String)
  문자열 길이(length)와 문자인덱스(index) 범위
  문자열의 동등(equals)비교
  기초형 자료형의 문자열 변환(String.valueOf)
  Scanner 문자열 콘솔 입력
  
  블록(Block)과 범위(Scope)
  지역변수(Local Variable)와 범위
  
  조건문(if-then, if-else, if-elseif-else)과 실행흐름